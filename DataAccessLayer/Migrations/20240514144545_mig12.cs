using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

#pragma warning disable CA1814 // Prefer jagged arrays over multidimensional

namespace DataAccessLayer.Migrations
{
    /// <inheritdoc />
    public partial class mig12 : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 136);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 137);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 138);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 139);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 140);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 141);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 142);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 143);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 144);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 145);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 146);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 147);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 148);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 149);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 150);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 151);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 152);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 153);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 154);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 155);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 156);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 157);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 158);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 159);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 160);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 161);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 162);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 163);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 164);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 165);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 166);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 167);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 168);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 169);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 170);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 171);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 172);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 173);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 174);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 175);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 176);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 177);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 178);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 179);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 180);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 181);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 182);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 183);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 184);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 185);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 186);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 187);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 188);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 189);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 190);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 191);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 192);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 193);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 194);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 195);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 196);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 197);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 198);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 199);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 200);

            migrationBuilder.DeleteData(
                table: "Paragraphs",
                keyColumn: "ParagraphID",
                keyValue: 201);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 136);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 137);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 138);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 139);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 140);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 141);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 142);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 143);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 144);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 145);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 146);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 147);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 148);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 149);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 150);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 151);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 152);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 153);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 154);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 155);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 156);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 157);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 158);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 159);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 160);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 161);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 162);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 163);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 164);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 165);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 166);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 167);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 168);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 169);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 170);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 171);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 172);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 173);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 174);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 175);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 176);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 177);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 178);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 179);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 180);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 181);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 182);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 183);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 184);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 185);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 186);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 187);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 188);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 189);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 190);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 191);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 192);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 193);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 194);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 195);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 196);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 197);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 198);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 199);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 200);

            migrationBuilder.DeleteData(
                table: "Categories",
                keyColumn: "CategoryID",
                keyValue: 201);

            migrationBuilder.InsertData(
                table: "Lectures",
                columns: new[] { "LectureId", "LectureContent" },
                values: new object[,]
                {
                    { 2, "Homomorfik şifreleme, şifrelenmiş veriler üzerinde önce şifresini çözmeden hesaplamalar yapmaya izin veren bir şifreleme şeklidir. Hesaplamanın sonucu şifrelenmiş bir formdadır, şifresi çözüldüğünde çıktı, şifrelenmemiş veriler üzerinde işlemlerin gerçekleştirilmiş hali ile aynıdır. Homomorfik şifreleme, dış kaynaklı depolama, hesaplama ve gizliliği korumak için kullanılabilir. Bu verilerin şifrelenmiş haldeyken işlenmesi için ticari bulut ortamlarına şifrelenmesine ve dışarıdan kaynaklanmasına olanak tanır. Yüksek düzeyli olan endüstrilerde homomorfik şifreleme, veri paylaşımını engelleyen gizlilik engellerini kaldırarak yeni hizmetleri etkinleştirmek için kullanılabilir.\r\n" },
                    { 3, "Homomorfik şifreleme, şifreli metinlerde hesaplama yapılmasına olanak sağlayan ve şifresi çözüldüğünde düz metin üzerinde yapılmış gibi işlemlerin sonucuyla eşleşen şifreli bir sonuç üreten bir şifreleme yöntemidir. Bu teknolojiyle, bilgi işlem gücü isteyen kullanıcılar artık bulut sunucuya düz metin açamayacak ve bu da veri sızıntısını etkili bir şekilde önleyebilecektir.\r\n" },
                    { 4, "Homomorfik şifreleme, gizli anahtara erişim olmadan şifrelenmiş veriler üzerinde hesaplama yapmak için ek bir değerlendirme özelliğine sahip bir şifreleme biçimidir. Böyle bir hesaplamanın sonucu şifrelenmiş olarak kalır. Homomorfik şifreleme, simetrik anahtar veya açık anahtar şifrelemesinin bir uzantısı olarak görülebilir. Homomorfik, cebirdeki homomorfizmi ifade eder: şifreleme ve şifre çözme fonksiyonları, düz metin ve şifreli metin uzayları arasındaki homomorfizmler olarak düşünülebilir.\r\n" },
                    { 5, "Homomorfik şifreleme, şifrelenmiş veriler üzerinde farklı hesaplama sınıfları gerçekleştirebilen çok sayıda şifreleme şeması içerir. Bazı homomorfik şifreleme çeşitleri;\r\n" },
                    { 6, "Derin öğrenme için en kullanışlı şifreleme türüdür. Herhangi bir sayıda toplama ve çarpma işlemine izin verir." },
                    { 7, "Toplama ve çarpma gibi işlemlere izin verir, fakat gerçekleştirilebilecek işlem sayısı açısından sınırlıdır." },
                    { 8, "Toplama ve çarpma gibi işlemlere izin verir. Sınırsız işlem yapılabilir." },
                    { 9, "Şifreleme işlemi bir bilgiyi bir yerden bir yere güvenli bir biçimde\r\n				aktaralılmasını sağlamanın yanında bilginin güvenli bir şekilde saklanmasınıda\r\n				sağlamaktadır. Bilgi saklama, bilgiyi göndermede olduğu gibi bilginin bir anahtar ile\r\n				şifrelenmesi ve bir alanda saklanması şeklinde gerçekleşir. Anahtara sahip kullanıcılar\r\n				veya günümüzde çok fazla kullanımı olan bulut hizmetlerinide kapsayan servis\r\n				sağlayıcıları bilgiler üzerinde özel haklara sahiptir. Anahtarın doğrudan bir paylaşımı\r\n				olmasa bile, bilgi, üçüncü bir taraf ile yapılması gereken bir işlem için paylaşılması\r\n				gerekebilir. Tam bu noktada bilginin güvenliğine karşı bir zafiyet oluşmaktadır.\r\n				Homomorfik Şifreleme, bilgi üzerinde yapılmak istenilen matematiksel işlemi\r\n				şifrelenmiş metin üzerinde yapılmasını olanak sağlayan bir kriptografik yöntemdir. Bu\r\n				sayede, bilgiler üzerinde işlemler güvenli bir şekilde yapılabilir.\r\n				Bilgiyi bozmadan, şifrelenmiş veriler üzerinde basit işlemlerin yapılabilmesi\r\n				düşüncesi ilk olarak 1978 yılında Rivest, Adleman ve Derouzous tarafından ortaya\r\n				atılmıştır. 1978’den bu yana bu konu önem kazanmış ve bu konuda sayısız çalışma\r\n				yapılmıştır." },
                    { 10, "2009 yılına kadar RSA, ElGamal ve Pailler algoritmaları gibi birçok algoritmada\r\n				uygulanmış, fakat sadece tek bir işlem tipi yapılabilmesine olanak sağlamıştır. 2009\r\n				yılında Craig Gentry şifreli veriler üzerinde birden fazla işlem yapabilme yani TamHomomorfik Şifreleme fikrini yayınlaması ile bu konu tekrardan önem kazanmıştır.\r\n				Bunun büyük bir başarı olmasına karşın,bu konunun iyileştirilmesi, uygulanması ve var\r\n				olan uygulamalar ile uyumlu hale getirilmesi gerektiği gösterilmiştir" },
                    { 11, "Şifreleme bilgilerin güvenliğini sağlamak için çok önemlidir. Fakat geleneksel\r\n				şifreleme yöntemleri bilgiler üzerinde yapılacak işlemleri, şifre çözmeden\r\n				gerçekleştiremez. Bunun yanı sıra, günümüzde yaygın olarak kullanılan bulut sistemleri\r\n				ile bilgilerin depolanması ve paylaşılması gizliliğimizden ödün vermemizi\r\n				gerektirmektedir. Bilgilerin hem rahatça paylaşılması hem de güvenliğinin sağlanması\r\n				için şifrelenmiş bilgiler üzerinde işlemlerin yapılabilmesine olanak sağlayacak bir\r\n				yapının olması gerekmektedir.\r\n				Özet olarak bu yapının gereksinimlerini şöyle sıralayabiliriz;" },
                    { 12, "Açık metin üzerinde değil şifrelenmiş metin üzerinde matematiksel işlemler\r\n					yapılmalıdır." },
                    { 13, "Şifreli metnin şifresi çözüldüğünde elde edilen sonuç, aynı işlemlerin açık\r\n					metin üzerinde yapılması ile elde edilecek sonuç ile aynı olmalıdır." },
                    { 14, "Bu gereksinimleri sağlayan yapılara Homomorfik Şifreleme yapıları\r\n				denilmektedir." },
                    { 15, "Örnek olarak, A kişisi 1’e 2'yi eklemek istiyor fakat sayıların nasıl ekleneceğini bilmiyor.\r\n						A bu problemi çözmek için başka birinden yani B kişisinden yardım almak istiyor.\r\n						Fakat A kişisi elinde bulunan 1 ve 2’yi güvenlik nedeni ile herhangi biri ile paylaşmakta\r\n						istemiyor. Bundan dolayı A kişisi yardım almak istediği B kişisine aynı zaman\r\n						güvenmemektedir. A kişisi hem 1’e 2’yi eklemek için B kişisinden yardım alıp hem de\r\n						B kişisine hangi sayıları eklemek istedi bilgisini vermeden bu işlemi gerçekleştirmek\r\n						için önce elindeki sayıları (1,2) şifreleme işlemi gerçekleştirerek yeni sayılar elde eder.\r\n						Şifreleme(1) = 33, Şifreleme(2) = 54. A kişisi elde ettiği bu sayıları ve yapmak istediği\r\n						toplama işlemini (f) B kişisine gönderir. B kişisi sadece şifrelenmiş olan 33 ve 54\r\n						sayılarını bilmektedir. B kişisi bu sayıları toplar 33 + 54 = 87 ve sonucu A kişisine geri\r\n						gönderir. A kişisi gelen cevabı şifre çözme işlemi gerçekleştirerek Şifre çözme (87) = 3\r\n						cevabına ulaşmış olur.\r\n						Yani HE, şifreli metin üzerinde işlem gerçekleştirebileceğiniz ve\r\n						bu sonucun şifresi çözüldüğü\r\n						ile aynı olacaktır." },
                    { 16, "Yani HE(Homomorphic Encryption),şifreli metin üzerinde işlem gerçekleştirebileceğiniz ve elde edeceğiniz\r\n				bu sonucun şifresi çözüldüğü zaman, açık metin ile bu işlemi gerçekleştirdiğiniz sonuç ile aynı olucaktır." },
                    { 17, "Bu sayede bilgilerin gizliliği sürdürülerek güvenli bir şekilde bilgiler üzerinde\r\n				matematiksel işlemler yapılabilmektedir." },
                    { 18, "Kısmi homomorfik şifreleme, belirli matematiksel işlemleri gerçekleştirmek için \r\n				kullanılan bir şifreleme tekniğidir. Tam homomorfik şifreleme gibi, kısmi homomorfik \r\n				şifreleme de verileri şifreli olarak saklayıp işlem yapmayı mümkün kılar. Ancak, tam homomorfik\r\n				şifrelemeden farklı olarak, kısmi homomorfik şifreleme sadece belirli işlemler için \r\n				kullanılabilir.Kısmi-Homomorfik Şifreleme yönteminde ya çarpma işlemi ya da toplama\r\n				işlemi olmak üzere sadece bir tek işlem gerçekleştirebilir. RSA, ElGamal ve Paillier\r\n				Kısmi-Homomorfik Şifreleme özelliği göstermektedir." },
                    { 19, "Bu tür, şifreli veriler arasında çarpma işlemi yapılmasına \r\n						olanak tanır. Ancak, şifreli veriler üzerinde sadece çarpma\r\n						işlemi yapılabilir, toplama işlemi yapılamaz." },
                    { 20, "Bu tür, şifreli veriler arasında toplama işlemi yapılmasına olanak tanır.\r\n						Şifreli veriler üzerinde sadece toplama işlemi yapılabilir, çarpma işlemi yapılamaz." },
                    { 21, "Kısmi homomorfik şifreleme, özellikle bulut bilişim ve veri güvenliği gibi alanlarda \r\n				kullanışlıdır. Örneğin, veri analizi veya hesaplama yaparken, hassas verilerin gizliliğini \r\n				koruyarak işlem yapılmasını sağlar. Ancak, tam homomorfik şifreleme kadar geniş bir \r\n				kullanım alanına sahip olmayabilir, çünkü yalnızca belirli işlemleri gerçekleştirmek için kullanılabilir." },
                    { 22, "RSA algoritması bilinen ilk Homomorfik Şifreleme yöntemlerinden biridir.\r\n				Çarpmaya göre Kısmi-Homomorfik Şifreleme özelliği gösterir. 𝑚1 1.\r\n				açık metin, 𝑚2 2. açık metin, 𝑛 mod değeri, 𝑦 açık anahtar olsun. RSA algoritmasının\r\n				çarpmaya göre Kısmi-Homomorfik Şifreleme özelliğini aşağıdaki gibi gösterilebilir;" },
                    { 23, "Görüldüğü gibi iki açık metinin şifrelenmiş olarak çarpımı açık metin\r\n				olarak çarpımının şifrelenmiş haline eşittir." },
                    { 24, "ElGamal algoritması toplamaya göre Homomorfik Şifreleme özelliği\r\n				göstermektedir. 𝑚1 1. açık metin, 𝑚2 2. açık metin, 𝑦 mod değeri,\r\n				𝐾ortak anahtar olsun. ElGamal algoritmasının toplamaya göre Kısmi-Homomorfik\r\n				Şifreleme özelliğini aşağıdaki gibi gösterilebilir;" },
                    { 25, "Görüldüğü gibi iki açık metinin şifrelenmiş olarak toplamı açık metin\r\n				olarak toplamının şifrelenmiş haline eşittir." },
                    { 26, "Paillier algoritması toplamaya göre Homomorfik Şifreleme özelliği\r\n				göstermektedir.Şifrelenmiş metinlerin toplamı, açık metinlerin\r\n				toplamına eşittir. 𝑚1 1. açık metin, 𝑚2 2. açık metin, 𝑛 mod değeri, 𝑔 açık anahtar, 𝑟\r\n				seçilen rastgele değer olsun. Paillier algoritmasının toplamaya göre Kısmi-Homomorfik\r\n				Şifreleme özelliğini aşağıdaki gibi gösterilebilir;" },
                    { 27, "Görüldüğü gibi iki açık metinin şifrelenmiş olarak toplamı açık metin\r\n				olarak  toplamının şifrelenmiş haline eşittir." },
                    { 28, "Tam-Homomorfik Şifreleme, şifreli veriler üzerinde yapılan işlemler tek bir\r\n				işlem tipiyle sınırlı kalmadan, farklı işlem tiplerini sayısız sayıda yapmaya izin veren\r\n				yapılardır. Tam-Homomorfik Şifreleme yapısı temelde halka\r\n				homomorfizmi olarak düşünülebilir." },
                    { 29, "2009 yılında, Gentry ilk Tam-Homomorfik Şifreleme yapısını açıkladı. Bu yapı\r\n				Kısmi-Homomorfik ve Homomorfik Benzeri Şifrelemelerinin aksine hem toplama hem\r\n				çarpma işlemlerini bir arada ve sınırsız sayıda yapmayı destekliyordu. Gentry’nin\r\n				sunduğu yapı sadece bir Tam-Homomorfik Şifreleme yapısı olmasından bir yana, TamHomomorfik Şifreleme yapısı oluşturabilmek için nasıl bir yol izlenmesi gerektiğini\r\n				anlatıyordu. Gentry’nin sunduğu yapıdan sonra birçok kişi yeni bir Tam-Homomorfik\r\n				yapı tasarlamaya çalıştı." },
                    { 30, "Gentry’nin önerdiği yapı ideal kafes (ideal lattice) tabanlı bir yapıydı.\r\n				Gentry’nin sunduğu Tam-Homomorfik Şifreleme yapısından öncede kafes tabanlı\r\n				kriptoloji üzerinde çalışmalar devam etmekteydi. Bu yapı teorik olarak çok önemli bir\r\n				yeri olsa da, uygulanabilirliği konusunda hesaplama maliyeti gibi sebeplerden dolayı\r\n				çok verimli değildi. Bu yapının daha verimli bir hale getirilmesi için birçok çalışma\r\n				yapılmıştır.Yapılan yeni çalışmaların çoğu kafes problemlerindeki zorluğu güvenlik\r\n				olarak kullanmasına dayanmaktadır." },
                    { 31, "Gentry, ideal kafeslere dayanan SWHE bir yapı kurarak başlamıştır. Fakat belirli\r\n				bir işlem sayısından sonra elde edilen sonuçlar başarısız olmuştur. Bunun sebebi şifreli\r\n				metindeki gürültü miktarının fazla olmasından kaynaklıdır. Gentry,\r\n				blue print method denilen, Önyükleme (boostrapping) ve şifre çözme devresini\r\n				önyükleme yapılabilir hale getirmek için bir teknik (squashing) işlemlerini önerdi.\r\n				Boostrapping ve squashing işlemleri tekrar edebilir özelliktedir. Bundan dolayı\r\n				oluşturulan yapı bu işlemlere sokularak sınırsız sayıda toplama ve çarpma işlemi\r\n				gerçekleştirebilecektir." },
                    { 32, "Toplamı gizli anahtarın çarpımının tersine eşit olan bir vektör\r\n				kümesi seçilir. Eğer şifreli metin bu kümenin elemanları ile çarpılırsa devrenin polinom\r\n				derecesi şemanın kaldırabileceği seviyeye indirgenir. Şifreli metin artık boostrapping\r\n				yapılabilir bir durumdadır." },
                    { 33, "Şifrelenmiş metin içerisindeki gürültüyü ortadan kaldırmak için\r\n				şifreli metini yeniden şifreleme işlemidir. Squashing işlemi gerçekleştirilerek\r\n				boostrapping yapılabilir bir duruma gelen şifreli metin boostrapping işlemi\r\n				gerçekleştirilerek yeni şifreli metin elde edilir." },
                    { 34, "Yani, gürültü içeren şifreli metni şifre çözme işlemi uygulayarak gürültüyü\r\n				kaldırır ve sonradan tekrar şifreleme işlemi gerçekleştiğinde küçük gürültülü bir hale\r\n				getirir. Bu işlem gürültünün eşik noktasına ulaşana kadar tekrarlanabilir. Gentry’nin\r\n				sunduğu bu yapıda maliyetin çok fazla olduğu görülmektedir. Bu şekilde bir SWHE\r\n				yapısı oluşturup, squashing ve boostrapping işlemleri gerçekleştirerek bir FHE yapısı\r\n				oluşturulabilir." },
                    { 35, "Biraz homomorfik şifreleme (SHE), şifrelenmiş veriler üzerinde sınırlı bir şekilde matematiksel işlemler yapabilme yeteneğine sahip bir şifreleme türüdür. Bu tür şifreleme, verilerin gizliliğini korurken işlemler yapma ihtiyacı olan çeşitli uygulamalar için önemlidir.\r\n\r\n				Temel olarak, SHE şifreleme şeması, şifrelenmiş veriler üzerinde sınırlı bir homomorfik özelliğe sahiptir. Bu özellik, belirli matematiksel işlemleri gerçekleştirmenize olanak tanırken, şifrelenmiş verinin gizliliğini korur. SHE'nin en yaygın olarak kullanılan örneği, homomorfik olarak toplama işlemlerini gerçekleştirebilme yeteneğidir. Yani, iki şifreli sayıyı toplayabilir ve sonucu şifreli olarak elde edebilirsiniz.\r\n\r\n				Ancak, SHE'nin tam homomorfik şifreleme (FHE) kadar geniş bir işlem yelpazesine sahip olmadığını belirtmek önemlidir. SHE, çarpma gibi daha karmaşık işlemleri gerçekleştirmek için genellikle yetersizdir. Bu nedenle, SHE genellikle belirli uygulamalar için yeterli olan bir orta yol sağlar.\r\n\r\n				Özetle, SHE, verilerin gizliliğini korurken sınırlı matematiksel işlemler gerçekleştirmenizi sağlayan bir şifreleme türüdür. Bu özellikle bulut hesaplama, veri analizi gibi alanlarda gizliliğin korunması gereken durumlarda kullanılabilir." },
                    { 36, "Günümüzde insanların genom haritaları çıkarılma çalışmaları hızlı bir şekilde\r\n				sürmektedir. Yakın bir gelecekte dünya üzerindeki insanların birçoğunun genom\r\n				haritalarına sahip olacağız. Biyoloji, tıp ve insanlığın varoluşu konuları hakkında bu\r\n				bilgilerin bize yardımcı olmaları beklenmektedir. Genom haritaları bilgisi\r\n				laboratuarlarda ve tıp merkezlerinde tutulmaktadır. Fakat bu verilerin saklanmasında ve\r\n				paylaşılmasında insanların güvenliği ve gizliliği açısından sıkıntılar doğmaktadır. DNA\r\n				ve RNA bir insanın parmak izi gibi özel bir tanımıdır. Bu bilgilerin güvenliğinin\r\n				sağlanmadan paylaşılması büyük bir sorun teşkil etmektedir.\r\n				Genom verilerin korunması National Institutes of Health tarafından\r\n				sağlanmaktadır. Bu verilere güvenli erişim için devlet kontrolü altında veya güvenilir\r\n				ortaklar tarafından erişim sağlanmaktadır. Bu verilerin hızlı bir şekilde artmasından\r\n				dolayı bulut tabanlı yeni çalışmalar önerildi. Fakat şuan için bu verilerin bulut ortamına\r\n				aktarılması güvenli değildir.\r\n				Genom verilerinin bazıları veriler üzerinde işlemlerin yapılarak belirli bir sonuç\r\n				elde etmeye dayanmaktadır. HE yöntemi ile buluta yüklenecek genom verilerinin\r\n				bazıları üzerinde güvenli bir şekilde işlem yapılabilirliği sağlanabilir." },
                    { 37, "Hükümete bağlı bulunan bina, şebeke, jeneratör vb. gibi yapıların birbiri ile\r\n				bağlantılığı olduğu akıllı bir şebeke ağı oluştuğunda, bu yapılar belirli bir veri\r\n				üretecektir. Bu verilerin çeşitli hükümet organları ile paylaşılarak gerekli analizlerin ve\r\n				incelemelerin yapılması gerekmektedir. Bu işlemlerin güvenli bir şekilde yapılabilmesi\r\n				için HE yapısından faydalanarak gerekli hesaplamalar ve incelemeler yapılabilir. Bu tür\r\n				bilgiler ile kötü amaçlı yazılımlar, anormallikler ve izinsiz girişlerin tespiti yapılarak\r\n				güvenlik sağlanabilir.\r\n				Böyle bir yapı çok fazla alandan çok fazla bilgi içerdiği için bu bilgileri korumak\r\n				ve kötü kişiler tarafından ele geçirilmediğini sağmak çok önemlidir. Örnek olarak,\r\n				şebeke ve güç dağılımı bilgilerinin kötü kişiler tarafından ele geçirildiğinde, bu alanlara\r\n				saldırılar olabilir.\r\n				Herhangi başka bir uygulama ile bu güvenliği sağlamak, uygulamada kullanılan\r\n				yöntemlerin belirgin olamaması, algoritmaların bilinmemesi ve protokollerin\r\n				güvenilirliğinin test edilememesi durumlarından dolayı kesin değildir. Bu nedenle kritik\r\n				alanlarda HE yöntemi kullanmak çok daha iyi olabilmektedir." },
                    { 38, "ABD’de her geçen yıl 1 milyondan fazla öğrenci lise zamanı okulu\r\n				bırakmaktadır (2017 verilerine göre). Liseye başlayan öğrencilerin çeyreği okulunu\r\n				zamanında bitirememektedir. Bu problemi en aza indirgemek için; liseyi bitirememe ve\r\n				liseyi zamanında tamamlayamama grubunda olabilecek öğrencileri liseye başlamadan\r\n				önce tespit edip gerekli önlemler alınabilir. Böyle bir tespitin yapılabilmesi için\r\n				hükümete bağlı okul, hastane, polise vb. kurumlardaki bilgilerin birleştirerek analiz\r\n				edilmesi gerekmektedir.Fakat bu kurumların hepsinin kendi bilgilerini koruma ve\r\n				güvenliğin sağlamakla yükümlüdür.\r\n				Bütün bu bilgilerin tek yerde tutulması büyük bir risk oluşturmaktadır. Bu denli\r\n				büyük bir bilgi kötü kişiler tarafından ele geçirmeye çalışılabilir ve sürekli saldırı\r\n				altında olabilir.\r\n				HE yapısından faydalanarak bu bilgilerin herhangi bir yere taşınmasına gerek\r\n				kalmadan hesaplanabilir hale getirilebilir. Bu şekilde güvenlik en üst düzeyde tutulmuş\r\n				olacaktır." },
                    { 39, "Sağlık hizmetlerinde kişilerin hassas bilgileri bulunmaktadır. Bu bilgilerin\r\n				güvenliğinin iyi sağlanması kötü kişiler tarafından ele geçirilmemesi çok önemlidir.\r\n				Fakat bir yandan bu bilgilerin sürekli olarak işlenmesi gerekmektedir. Risk ve fayda\r\n				arasındaki bu bilgilerin doğru bir şekilde korunmadığında bilgi kaybının yanında büyük\r\n				maliyetlere sebep olduğu görülmektedir.\r\n				HE yapısı sağlık hizmetlerindeki bilgilerin risk ve fayda dengesini sağlamada rol\r\n				oynayabilir. Fatura, rapor oluşturma gibi yapılacak işlemlerin yapılması sırasında\r\n				bilgilerin gizli kalmasını sağlayıp sadece sonucun elde edilmesini sağlayabilir. Bu\r\n				şekilde verilerin güvenliği sağlanarak, büyük maliyetlere sebebiyet verecek olaylardan\r\n				korunmasını sağlar." },
                    { 40, "Bulut Bilişim, günümüzde popüler bir şekilde kullanılan internet üzerinde\r\n				verilerin depolanabileceği bir teknolojidir. Bulut bilişim, ulaşılabilirliğin kolay olması\r\n				ve maliyetinin düşük olmasından dolayı çok tercih edilmektedir. Aynı zamanda kişisel\r\n				verilerin bu teknoloji üzerinde tutulmasından dolayı, saldırganlar için potansiyel bir\r\n				saldırma yeridir. Saldırıya uğrayan bir bulutun, kişisel verileri nasıl koruyacağına dair\r\n				sorunlar gündeme gelmektedir. Bu sorunu çözebilmek için bulut üzerinde tutulan\r\n				verilerin şifreli bir şekilde saklanması gerekmektedir. Saldırgana kullanıcı verilerine\r\n				ulaşabile şifreli oldukları için herhangi bir şey elde edemez. Fakat verilerin şifreli bir\r\n				şekilde tutulması kullanıcıların verilerine ulaşmak istemesi veya üzerinde değişiklikler\r\n				yapmak istemesi halinde şifreleme ve şifre çözme işlemleri gerçekleştirmek\r\n				gerekmektedir. Bu işlemler ek maliyetler getirecektir.\r\n				HE yapısı bulut bilişiminde kullanılabilir. HE yapısı sayesinde şifrelenmiş\r\n				olarak saklanan veriler üzerinde kullanıcılar gerekli işlemleri gerçekleştirerek maliyet\r\n				düşürülebilir. Veriler şifreli olacağı için saldırganlar tarafından da korunaklı bir yapı\r\n				haline gelecektir." },
                    { 41, "Mobil ajanlar, kullanıcıların önceden belirlenmiş olan görevleri kullanıcıların\r\n				müdahalesi gerekmeden başka bilgisayarlar üzerinde gerçekleştiren programlardır.\r\n				Mobil ajanların çalıştığı diğer bilgisayarların kötü niyetli\r\n				kişiler tarafınca kontrol edilebilmesinden dolayı güvenlik açığı ortaya çıkmaktadır.\r\n				Bundan dolayı mobil ajanları kötü niyetli kişiler tarafından korumak ve işlemlerini\r\n				gerçekleştirmek için HE yapısı kullanılabilir. Verileri, mobil ajanlar tarafından başka\r\n				bilgisayarlarda kullanılmadan önce şifrelemek ve sonrasında şifreli veriler üzerinde\r\n				hesaplama yapmak için HE yapısından faydalanılabilir." },
                    { 42, "Elektronik ortamda gizli oylama sistemlerinde, oylar üzerinde işlemlerin\r\n				yapılması gerekmektedir. Yapılacak olan bu işlemler sırasında, oy veren bireylerin\r\n				kullandıkları oy hakkındaki bilgilerin gizlilik nedeni ile ortaya çıkarılmaması\r\n				gerekmektedir. Şifreli olarak saklanan oylar üzerinde işlem yapabilmek için HE yapısı\r\n				kullanılabilir. Bu sayede oylar üzerinde analizler yapılırken, oyların gizliliği\r\n				sürdürülebilir." },
                    { 43, "Avuç ve parmak izi tanıma teknolojileri özellikle son yıllarda daha fazla\r\n				kullanılmaya başlamıştır. Avuç ve parmak uçlarındaki deri üzerindeki dalgalanmaların\r\n				karakteristik bir yapıya sahip olmasında dolayı, bu veriler ile tanımlama işlemleri\r\n				gerçekleştirilmektedir. Bu uygulamaların sahip\r\n				olduğu kişisel avuç ve parmak izi verilerinin şifreli bir şekilde tutularak ve gerektiğinde\r\n				bu işlemlerin şifreli bir şekilde yapılması güvenlik için önemlidir. HE yapısı ile bu\r\n				uygulamalardaki güvenlik arttırılabilir." },
                    { 44, "Finansal sektörde müşteriler tarafından şirketlere yapılacak yatırımlar, şirket\r\n				hakkındaki bilgiler doğrultusunda yapılmaktadır. Bu bilgiler, şirketin performansı,\r\n				envanter durumu gibi bilgilerden oluşmaktadır. Bu bilgiler üzerinde hesaplamalar\r\n				yapılarak şirket hakkında gerekli bilgiye sahip olan müşteri yatırım yapıp\r\n				yapmayacağına karar verir. Şirketler bu bilgileri avantajlarını koruyabilmek için gizli\r\n				tutmak isteyebilirler.\r\n				Şirketler HE yapısı kullanılarak bu bilgileri açık bir şekilde yayınlamadan\r\n				müşteriler tarafından kullanılabilir bir yapı oluşturabilir. Bu sayede şirketler bilgilerini\r\n				açık bir şekilde paylaşmamış ve müşteriler şirket bilgileri hakkında yapmak istedikleri\r\n				hesaplamaları yapabilirler." },
                    { 45, "Reklam, satıcının sattığı ürün veya hizmetin müşteriler tarafından bilinmesini\r\n				sağlayan bir araçtır. Reklam veren satıcıların asıl ulaşmak istedikleri kişiler potansiyel\r\n				alıcılardır. Potansiyel alıcıların kimler olduğunu belirlemek için, insanların kullandıkları\r\n				bilgisayar, telefon gibi iletişim içerisinde olan elektronik eşyalar kullanılır. Bu eşyaları\r\n				kullanan insanların; aradıkları kelimeler, ilgi alanları, e-postalar, konum bilgileri gibi\r\n				bilgilerini toplayarak, o kişi hakkında bilgi sahibi olunabilir. Toplanan bu bilgiler\r\n				sayesinde reklam yapan satıcıların sattığı ürünün veya hizmetin potansiyel alıcısı olduğu\r\n				tahmin edilen kişilere sunulması. Bu sayede satıcıların müşterileri ile kolay bir şekilde\r\n				buluşması sağlanabilir.\r\n				HE yapısı sayesinde kişilerden toplanan kişisel bilgilerin açık olarak saklanması\r\n				gerekmemektedir. Şifreli olarak saklanan bilgilerin, gerektiğinde şifreli olarak işlem\r\n				yapılarak sonuçları üzerinden potansiyel alıcılar belirlenebilir." },
                    { 46, "Veri kümeleme, ağ içerisinde bulunan algılayıcıların veri miktarlarını düşürerek\r\n				enerji tasarrufu yapmasını sağlayan bir yapıdır. Güvenlik sorunları ile karşılaşılmaması\r\n				için veri gönderecek tarafın veriyi şifreleyerek baz istasyonuna göndermesi\r\n				gerekmektedir. Fakat verinin gideceği yol üzerindeki algılayıcılar veriyi açık metin\r\n				haline getirerek veri kümele işlemi yapması gerekmektedir. Güvenlik ve veri kümeleme\r\n				birbirlerine zıt bir şekilde çalışmaktadır.\r\n				Veriyi baz istasyonuna gönderen taraf veriyi simetrik anahtar şifreleme ile\r\n				göndermektedir. Ağ üzerindeki algılayıcılar şifre çözme işlemi ile veriyi çözer, veri\r\n				kümeleme yapar ve sonrasında tekrar şifreleme işlemini gerçekleştirerek veriyi\r\n				gönderir. Veri bu işlemler sırasında gizliliğini yitirmektedir.\r\n				Hem veri gizliliğini sağlamak hem de veri kümele işlemini gerçekleştirmek için\r\n				HE yapısından faydalanılabilir. HE yapısı sayesinde veriyi baz istasyonuna gönderen\r\n				taraf veriyi şifreleyerek gönderir. Ağ üzerindeki algılayıcılar şifre çözme işlemini\r\n				gerçekleştirmeden veri kümele işlemini yapar ve veriyi gönderir. Bu sayede şifreli veri\r\n				yol boyunca açılmadı için veri gizliliği sağlanmış ve veri kümele işlemi\r\n				gerçekleştirilmiş olur." },
                    { 47, "IoT, etrafımıza etkide bulunan veya analiz etmemizi sağlayan cihazları etkileşim\r\n				içinde olmalarını sağlayan bir iletişim ağıdır. Bu iletişim ağı sayesinde üretim\r\n				süreçlerini, hasta takipleri, geri dönüşüm süreçleri, akıllı binalar gibi alanlarda kontrol\r\n				sağlanabilir ve analiz yapılabilir.\r\n				Standart şifreleme yöntemlerinden faydalanarak IoT oluşturulduğunda iki tane\r\n				problem ortaya çıkmaktadır. Eğer veriler şifrelenmemiş olarak depolanırsa, kötü niyetli\r\n				kişiler tarafından ele geçirilebilir. Eğer veriler şifrelenmiş olarak depolanırsa,\r\n				sağlayıcılar üzerinde çalışması için şifrenin çözülmesi gerekir.\r\n				HE sayesinde veriler şifrelenmiş şekilde depolanarak, şifre çözme işlemine gerek\r\n				kalmadan sağlayıcılar üzerinde işlem yapılabilir. RSA algoritması, ElGamal\r\n				algoritması, Paillier algoritması bu amaç ile kullanılabilir. IoT için Homomorfik\r\n				Şifreleme çok önemlidir. Çünkü bir yandan veri gizliliğini koruyarak, bir yandan da\r\n				sağlayıcılar ve düğüm noktalarında hızlı bir şekilde şifre çözme ve şifreleme işlemlerine\r\n				gerek duymadan gerçekleştirilebilir. Düğümlerde toplama ve çarpma işlemleri\r\n				gerçekleştirilerek işlem ve depolama maliyeti azaltılabilir. Bu sayede düşük güç\r\n				tüketimi gerçekleşmiş olur." },
                    { 48, "Veri tabanı düzenli şekilde verilerin saklandığı bilgi topluluğudur. Veri\r\n				tabanındaki verilere istenildiği zaman ulaşılabilir ve kullanılabilir.\r\n				Bu veriler veri tabanında güvenlik için şifreli bir şekilde bulunmaktadır. Fakat veriler\r\n				üzerinde gerçekleştirilecek işlemlerin yapılması sırasında bu verilerin şifrelerinin\r\n				çözülmesi ve açık metin üzerinde işlemlerin gerçekleşmesi gerekmektedir. Bu nedenle,\r\n				veri tabanındaki veriler güvenlik riskleri ile karşı karşıyadır.\r\n				HE yapısı veriler üzerinde şifre çözme işlemini gerçekleştirmeden işlemler\r\n				yapılabilmesine olanak sağlamaktadır. Bu sayede veri tabanında saklanan veriler\r\n				üzerinde işlemler güvenli bir şekilde gerçekleşebilir." },
                    { 49, "Ağ kontrol sistemleri siber güvenliğin en önemli konularından biridir. Su, ulaşım\r\n				ve elektrik ağları gibi endüstriyel ve kritik altyapılara uygulanır. Kötü niyetli kişiler bu\r\n				ağlara karşı saldırılarda bulunmaktadır. İletişim kanalları üzerinden gönderilen\r\n				sinyallerin güvenliği sağlanmalıdır (Kogiso & Fujita, 2015).\r\n				Kontrol cihazının parametrelerini ve kontrol cihazı içerisindeki sinyalleri\r\n				şifrelemek güvenlik açısından önemlidir. Kontrol cihazına gelene sinyal şifreli bir\r\n				şekilde gelerek şifre çözme işlemi gerçekleştirilir ve gerekli işlemlerin yapılması\r\n				sonucunda tekrar şifrelenerek şifreli olarak kontrol cihazından çıkış gerçekleştirir. HE\r\n				yapısı kontrol cihazlarında uygulandığında şifreli olarak gelen sinyal şifre çözme işlemi\r\n				gerçekleşmeden gerekli işlemler üzerinde gerçekleştirilerek şifreli olarak çıkış\r\n				gerçekleştirir. Bu sayede ağ kontrol cihazları üzerinde güvenlik arttırılmış olacaktır." },
                    { 50, "Açık arttırma bir malın, menkulün, eşyanın vb. ürünlerin alıcı ve satıcıların bir\r\n				arada bulunarak fiyat tekliflerinin bildirilmesi ile en yüksek fiyata sahip alıcının ürünü\r\n				almasıdır. Açık arttırmalar açık teklif veya kapalı teklif şeklinde ikiye ayrılmaktadır.\r\n				Açık teklif şeklinde gerçekleşen açık arttırmalarda, alıcılar fiyat tekliflerini açık bir\r\n				şekilde gerçekleştirirler. Kapalı teklif şeklinde gerçekleşen açık arttırmalarda, alıcılar\r\n				fiyat tekliflerini kapalı bir şekilde gerçekleştirirler.\r\n				Kapalı teklif açık arttırmalarda, alıcıların verdikleri teklifler gizli olmalıdır. Bu\r\n				tekliflerin açığa çıkması açık arttırmayı olumsuz yönde etkilemektedir. Bir yandan bu\r\n				tekliflerin karşılaştırma işlemleri gerçekleştirilmesi gerekmektedir. Burada üçüncü\r\n				şahıslara olan güven esas alınmaktadır.\r\n				HE yapısı kapalı teklif açık arttırmalarda uygulanabilir. Bu sayede alıcılar\r\n				tarafından verilen teklifler şifreli bir şekilde saklanır. Karşılaştırmaların yapılması için\r\n				şifreli olarak saklanan veriler şifre çözme işlemine gerek olmadan gerekli işlemler\r\n				üzerinde gerçekleştirilebilir. Bunun sonucunda, teklifler üçüncü bir şahıssa güven\r\n				olmayı gerektirmeden açık arttırma gerçekleşebilir." },
                    { 51, "Homomorfik şifreleme, verileri şifrelerken, şifrelenmiş veri üzerinde işlemler yapılabilir \r\n					hale getirir. Ancak bu işlemler sonucunda elde edilen çıktılar, şifrelenmiş veriden doğrudan anlamlı \r\n					bir şekilde yararlanılmasını önlemek için tekrar şifrelenmiş olmalıdır. Bu sayede, veri sahiplerinin \r\n					gizli verilerinin ifşa edilmesi önlenir." },
                    { 52, "Homomorfik şifreleme, şifreli veri üzerinde işlemler yapılabilmesini sağlar, ancak \r\n					bu işlemler sonucunda verinin bütünlüğünün korunması kritiktir. Yani, işlenmiş verinin, orijinal \r\n					veriden doğru bir şekilde türetildiğinden emin olunmalıdır." },
                    { 53, "Homomorfik şifreleme sistemlerinde kullanılan şifreleme \r\n					anahtarlarının güvenliği büyük önem taşır. Eğer bir saldırgan anahtarları ele geçirirse, bu \r\n					saldırganın şifrelenmiş veri üzerinde istediği işlemleri yapması mümkün olabilir." },
                    { 54, "Veri işleme sürecinde, verinin kim tarafından işlendiğinin \r\n					doğrulanması önemlidir. Bu nedenle, hem veri işleme sürecinin hem de işlem sonuçlarının \r\n					doğrulanması için güvenilir doğrulama mekanizmaları gereklidir." },
                    { 55, "Homomorfik şifreleme sistemleri, çeşitli saldırılara karşı dirençli olmalıdır. Özellikle\r\n					kriptografik saldırılara karşı dayanıklı olmalı ve saldırganların şifreli veriyi kırmak için \r\n					kullanabilecekleri yöntemlere karşı korunaklı olmalıdır." },
                    { 56, "Bu ilkeler, homomorfik şifreleme teknolojisinin güvenliği ve gizliliği sağlamak için temel alınan \r\n				prensiplerdir. Bu ilkeler, bu teknolojinin güvenilir ve etkili bir şekilde uygulanmasını sağlamak için\r\n				dikkate alınmalıdır." },
                    { 57, "Homomorfik şifreleme ve veri analitiği arasındaki ilişki, veri gizliliği ve güvenliği ile veri \r\n				analitiği arasında bir denge kurma ihtiyacından doğar. İşte bu konudaki potansiyeller ve zorluklar:" },
                    { 58, "Potansiyeller:" },
                    { 59, "Homomorfik şifreleme, verilerin analiz edilmesine olanak tanırken, aynı zamanda \r\n				verilerin gizliliğini korur. Bu, hassas verilerin analiz edilmesi için güvenli bir \r\n				ortam sağlar, çünkü veriler şifreli olarak kalır ve analiz sırasında açık metin haline gelmez." },
                    { 60, "Homomorfik şifreleme, farklı kurumlar arasında hassas verilerin güvenli bir şekilde\r\n				paylaşılmasını sağlar. Veriler şifreli olduğu için, paylaşım sırasında gizliliği \r\n				korunurken, analiz yapmak isteyen kurumlar bu verilere erişebilir." },
                    { 61, "Homomorfik şifreleme sayesinde, özellikle sağlık, finans ve diğer hassas alanlardaki\r\n				verilerin analizi mümkün hale gelir. Örneğin, sağlık verileri gibi özel\r\n				veriler, analiz edilirken bile gizliliği korunarak değerlendirilebilir." },
                    { 62, "Zorluklar:" },
                    { 63, "Homomorfik şifreleme, hesaplama yoğun işlemler gerektirir. Özellikle \r\n				büyük veri kümeleriyle çalışırken, homomorfik işlemlerin yapılması \r\n				zaman alabilir ve yüksek hesaplama gücüne ihtiyaç duyabilir.\r\n" },
                    { 64, "Homomorfik şifreleme, geleneksel veri analitiği yöntemlerine göre \r\n				daha yavaş olabilir. Bu nedenle, gerçek zamanlı analizler veya \r\n				hızlı yanıtlar gerektiren uygulamalarda kullanılması zor olabilir." },
                    { 65, "Homomorfik şifreleme, karmaşık kriptografik algoritmaları\r\n				gerektirir. Bu algoritmaların tasarımı ve uygulanması zor \r\n				olabilir ve hatalı bir şekilde uygulandığında güvenlik riski oluşturabilir." },
                    { 66, "Homomorfik şifreleme, verilerin boyutunu artırabilir. Özellikle şifreleme sırasında \r\n				veri genişleyebilir ve bu da depolama ve iletim maliyetlerini artırabilir." },
                    { 67, "Homomorfik şifreleme ve veri analitiği arasındaki ilişki, veri gizliliği ve analitik esneklik \r\n			arasında bir denge kurmayı gerektirir. Potansiyelleri, veri gizliliğini korurken veri analitiğini \r\n			mümkün kılar. Ancak zorluklar, performans, hesaplama gücü ve kriptografik zorluklar gibi teknik engellerle karşılaşabilir." }
                });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 2);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 3);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 4);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 5);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 6);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 7);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 8);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 9);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 10);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 11);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 12);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 13);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 14);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 15);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 16);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 17);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 18);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 19);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 20);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 21);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 22);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 23);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 24);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 25);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 26);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 27);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 28);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 29);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 30);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 31);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 32);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 33);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 34);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 35);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 36);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 37);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 38);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 39);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 40);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 41);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 42);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 43);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 44);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 45);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 46);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 47);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 48);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 49);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 50);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 51);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 52);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 53);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 54);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 55);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 56);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 57);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 58);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 59);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 60);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 61);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 62);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 63);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 64);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 65);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 66);

            migrationBuilder.DeleteData(
                table: "Lectures",
                keyColumn: "LectureId",
                keyValue: 67);

            migrationBuilder.InsertData(
                table: "Categories",
                columns: new[] { "CategoryID", "CategoryDescription", "CategoryName", "CategoryStatus" },
                values: new object[,]
                {
                    { 136, "İçerik", "Paragraph", true },
                    { 137, "İçerik", "Paragraph", true },
                    { 138, "İçerik", "Paragraph", true },
                    { 139, "İçerik", "Paragraph", true },
                    { 140, "İçerik", "Paragraph", true },
                    { 141, "İçerik", "Paragraph", true },
                    { 142, "İçerik", "Paragraph", true },
                    { 143, "İçerik", "Paragraph", true },
                    { 144, "İçerik", "Paragraph", true },
                    { 145, "İçerik", "Paragraph", true },
                    { 146, "İçerik", "Paragraph", true },
                    { 147, "İçerik", "Paragraph", true },
                    { 148, "İçerik", "Paragraph", true },
                    { 149, "İçerik", "Paragraph", true },
                    { 150, "İçerik", "Paragraph", true },
                    { 151, "İçerik", "Paragraph", true },
                    { 152, "İçerik", "Paragraph", true },
                    { 153, "İçerik", "Paragraph", true },
                    { 154, "İçerik", "Paragraph", true },
                    { 155, "İçerik", "Paragraph", true },
                    { 156, "İçerik", "Paragraph", true },
                    { 157, "İçerik", "Paragraph", true },
                    { 158, "İçerik", "Paragraph", true },
                    { 159, "İçerik", "Paragraph", true },
                    { 160, "İçerik", "Paragraph", true },
                    { 161, "İçerik", "Paragraph", true },
                    { 162, "İçerik", "Paragraph", true },
                    { 163, "İçerik", "Paragraph", true },
                    { 164, "İçerik", "Paragraph", true },
                    { 165, "İçerik", "Paragraph", true },
                    { 166, "İçerik", "Paragraph", true },
                    { 167, "İçerik", "Paragraph", true },
                    { 168, "İçerik", "Paragraph", true },
                    { 169, "İçerik", "Paragraph", true },
                    { 170, "İçerik", "Paragraph", true },
                    { 171, "İçerik", "Paragraph", true },
                    { 172, "İçerik", "Paragraph", true },
                    { 173, "İçerik", "Paragraph", true },
                    { 174, "İçerik", "Paragraph", true },
                    { 175, "İçerik", "Paragraph", true },
                    { 176, "İçerik", "Paragraph", true },
                    { 177, "İçerik", "Paragraph", true },
                    { 178, "İçerik", "Paragraph", true },
                    { 179, "İçerik", "Paragraph", true },
                    { 180, "İçerik", "Paragraph", true },
                    { 181, "İçerik", "Paragraph", true },
                    { 182, "İçerik", "Paragraph", true },
                    { 183, "İçerik", "Paragraph", true },
                    { 184, "İçerik", "Paragraph", true },
                    { 185, "İçerik", "Paragraph", true },
                    { 186, "İçerik", "Paragraph", true },
                    { 187, "İçerik", "Paragraph", true },
                    { 188, "İçerik", "Paragraph", true },
                    { 189, "İçerik", "Paragraph", true },
                    { 190, "İçerik", "Paragraph", true },
                    { 191, "İçerik", "Paragraph", true },
                    { 192, "İçerik", "Paragraph", true },
                    { 193, "İçerik", "Paragraph", true },
                    { 194, "İçerik", "Paragraph", true },
                    { 195, "İçerik", "Paragraph", true },
                    { 196, "İçerik", "Paragraph", true },
                    { 197, "İçerik", "Paragraph", true },
                    { 198, "İçerik", "Paragraph", true },
                    { 199, "İçerik", "Paragraph", true },
                    { 200, "İçerik", "Paragraph", true },
                    { 201, "İçerik", "Paragraph", true }
                });

            migrationBuilder.InsertData(
                table: "Paragraphs",
                columns: new[] { "ParagraphID", "CategoryID", "ParagraphContent", "ParagraphStatus", "ParagraphTitle" },
                values: new object[,]
                {
                    { 136, 136, "Homomorfik şifreleme, şifrelenmiş veriler üzerinde önce şifresini çözmeden hesaplamalar yapmaya izin veren bir şifreleme şeklidir. Hesaplamanın sonucu şifrelenmiş bir formdadır, şifresi çözüldüğünde çıktı, şifrelenmemiş veriler üzerinde işlemlerin gerçekleştirilmiş hali ile aynıdır. Homomorfik şifreleme, dış kaynaklı depolama, hesaplama ve gizliliği korumak için kullanılabilir. Bu verilerin şifrelenmiş haldeyken işlenmesi için ticari bulut ortamlarına şifrelenmesine ve dışarıdan kaynaklanmasına olanak tanır. Yüksek düzeyli olan endüstrilerde homomorfik şifreleme, veri paylaşımını engelleyen gizlilik engellerini kaldırarak yeni hizmetleri etkinleştirmek için kullanılabilir.\r\n", true, "Lecture" },
                    { 137, 137, "Homomorfik şifreleme, şifreli metinlerde hesaplama yapılmasına olanak sağlayan ve şifresi çözüldüğünde düz metin üzerinde yapılmış gibi işlemlerin sonucuyla eşleşen şifreli bir sonuç üreten bir şifreleme yöntemidir. Bu teknolojiyle, bilgi işlem gücü isteyen kullanıcılar artık bulut sunucuya düz metin açamayacak ve bu da veri sızıntısını etkili bir şekilde önleyebilecektir.\r\n", true, "Lecture" },
                    { 138, 138, "Homomorfik şifreleme, gizli anahtara erişim olmadan şifrelenmiş veriler üzerinde hesaplama yapmak için ek bir değerlendirme özelliğine sahip bir şifreleme biçimidir. Böyle bir hesaplamanın sonucu şifrelenmiş olarak kalır. Homomorfik şifreleme, simetrik anahtar veya açık anahtar şifrelemesinin bir uzantısı olarak görülebilir. Homomorfik, cebirdeki homomorfizmi ifade eder: şifreleme ve şifre çözme fonksiyonları, düz metin ve şifreli metin uzayları arasındaki homomorfizmler olarak düşünülebilir.\r\n", true, "Lecture" },
                    { 139, 139, "Homomorfik şifreleme, şifrelenmiş veriler üzerinde farklı hesaplama sınıfları gerçekleştirebilen çok sayıda şifreleme şeması içerir. Bazı homomorfik şifreleme çeşitleri;\r\n", true, "Lecture" },
                    { 140, 140, "Derin öğrenme için en kullanışlı şifreleme türüdür. Herhangi bir sayıda toplama ve çarpma işlemine izin verir.", true, "Fully-HE(FHE- Tam Homomorfik Şifreleme):" },
                    { 141, 141, "Toplama ve çarpma gibi işlemlere izin verir, fakat gerçekleştirilebilecek işlem sayısı açısından sınırlıdır.", true, "Somewhat-HE (SHE-Biraz Homomorfik Şifreleme):" },
                    { 142, 142, "Toplama ve çarpma gibi işlemlere izin verir. Sınırsız işlem yapılabilir.", true, "Partially-HE(PHE-Kısmen Homomorfik Şifreleme):" },
                    { 143, 143, "Şifreleme işlemi bir bilgiyi bir yerden bir yere güvenli bir biçimde\r\n				aktaralılmasını sağlamanın yanında bilginin güvenli bir şekilde saklanmasınıda\r\n				sağlamaktadır. Bilgi saklama, bilgiyi göndermede olduğu gibi bilginin bir anahtar ile\r\n				şifrelenmesi ve bir alanda saklanması şeklinde gerçekleşir. Anahtara sahip kullanıcılar\r\n				veya günümüzde çok fazla kullanımı olan bulut hizmetlerinide kapsayan servis\r\n				sağlayıcıları bilgiler üzerinde özel haklara sahiptir. Anahtarın doğrudan bir paylaşımı\r\n				olmasa bile, bilgi, üçüncü bir taraf ile yapılması gereken bir işlem için paylaşılması\r\n				gerekebilir. Tam bu noktada bilginin güvenliğine karşı bir zafiyet oluşmaktadır.\r\n				Homomorfik Şifreleme, bilgi üzerinde yapılmak istenilen matematiksel işlemi\r\n				şifrelenmiş metin üzerinde yapılmasını olanak sağlayan bir kriptografik yöntemdir. Bu\r\n				sayede, bilgiler üzerinde işlemler güvenli bir şekilde yapılabilir.\r\n				Bilgiyi bozmadan, şifrelenmiş veriler üzerinde basit işlemlerin yapılabilmesi\r\n				düşüncesi ilk olarak 1978 yılında Rivest, Adleman ve Derouzous tarafından ortaya\r\n				atılmıştır. 1978’den bu yana bu konu önem kazanmış ve bu konuda sayısız çalışma\r\n				yapılmıştır.", true, "HOMOMORFİK ŞİFRELEME" },
                    { 144, 144, "2009 yılına kadar RSA, ElGamal ve Pailler algoritmaları gibi birçok algoritmada\r\n				uygulanmış, fakat sadece tek bir işlem tipi yapılabilmesine olanak sağlamıştır. 2009\r\n				yılında Craig Gentry şifreli veriler üzerinde birden fazla işlem yapabilme yani TamHomomorfik Şifreleme fikrini yayınlaması ile bu konu tekrardan önem kazanmıştır.\r\n				Bunun büyük bir başarı olmasına karşın,bu konunun iyileştirilmesi, uygulanması ve var\r\n				olan uygulamalar ile uyumlu hale getirilmesi gerektiği gösterilmiştir", true, "HOMOMORFİK ŞİFRELEME" },
                    { 145, 145, "Şifreleme bilgilerin güvenliğini sağlamak için çok önemlidir. Fakat geleneksel\r\n				şifreleme yöntemleri bilgiler üzerinde yapılacak işlemleri, şifre çözmeden\r\n				gerçekleştiremez. Bunun yanı sıra, günümüzde yaygın olarak kullanılan bulut sistemleri\r\n				ile bilgilerin depolanması ve paylaşılması gizliliğimizden ödün vermemizi\r\n				gerektirmektedir. Bilgilerin hem rahatça paylaşılması hem de güvenliğinin sağlanması\r\n				için şifrelenmiş bilgiler üzerinde işlemlerin yapılabilmesine olanak sağlayacak bir\r\n				yapının olması gerekmektedir.\r\n				Özet olarak bu yapının gereksinimlerini şöyle sıralayabiliriz;", true, "Homomorfik Şifreleme" },
                    { 146, 146, "Açık metin üzerinde değil şifrelenmiş metin üzerinde matematiksel işlemler\r\n					yapılmalıdır.", true, "Homomorfik Şifreleme" },
                    { 147, 147, "Şifreli metnin şifresi çözüldüğünde elde edilen sonuç, aynı işlemlerin açık\r\n					metin üzerinde yapılması ile elde edilecek sonuç ile aynı olmalıdır.", true, "Homomorfik Şifreleme" },
                    { 148, 148, "Bu gereksinimleri sağlayan yapılara Homomorfik Şifreleme yapıları\r\n				denilmektedir.", true, "Homomorfik Şifreleme" },
                    { 149, 149, "Örnek olarak, A kişisi 1’e 2'yi eklemek istiyor fakat sayıların nasıl ekleneceğini bilmiyor.\r\n						A bu problemi çözmek için başka birinden yani B kişisinden yardım almak istiyor.\r\n						Fakat A kişisi elinde bulunan 1 ve 2’yi güvenlik nedeni ile herhangi biri ile paylaşmakta\r\n						istemiyor. Bundan dolayı A kişisi yardım almak istediği B kişisine aynı zaman\r\n						güvenmemektedir. A kişisi hem 1’e 2’yi eklemek için B kişisinden yardım alıp hem de\r\n						B kişisine hangi sayıları eklemek istedi bilgisini vermeden bu işlemi gerçekleştirmek\r\n						için önce elindeki sayıları (1,2) şifreleme işlemi gerçekleştirerek yeni sayılar elde eder.\r\n						Şifreleme(1) = 33, Şifreleme(2) = 54. A kişisi elde ettiği bu sayıları ve yapmak istediği\r\n						toplama işlemini (f) B kişisine gönderir. B kişisi sadece şifrelenmiş olan 33 ve 54\r\n						sayılarını bilmektedir. B kişisi bu sayıları toplar 33 + 54 = 87 ve sonucu A kişisine geri\r\n						gönderir. A kişisi gelen cevabı şifre çözme işlemi gerçekleştirerek Şifre çözme (87) = 3\r\n						cevabına ulaşmış olur.\r\n						Yani HE, şifreli metin üzerinde işlem gerçekleştirebileceğiniz ve\r\n						bu sonucun şifresi çözüldüğü\r\n						ile aynı olacaktır.", true, "Örnek 4.1" },
                    { 150, 150, "Yani HE(Homomorphic Encryption),şifreli metin üzerinde işlem gerçekleştirebileceğiniz ve elde edeceğiniz\r\n				bu sonucun şifresi çözüldüğü zaman, açık metin ile bu işlemi gerçekleştirdiğiniz sonuç ile aynı olucaktır.", true, "Lecture" },
                    { 151, 151, "Bu sayede bilgilerin gizliliği sürdürülerek güvenli bir şekilde bilgiler üzerinde\r\n				matematiksel işlemler yapılabilmektedir.", true, "Lecture" },
                    { 152, 152, "Kısmi homomorfik şifreleme, belirli matematiksel işlemleri gerçekleştirmek için \r\n				kullanılan bir şifreleme tekniğidir. Tam homomorfik şifreleme gibi, kısmi homomorfik \r\n				şifreleme de verileri şifreli olarak saklayıp işlem yapmayı mümkün kılar. Ancak, tam homomorfik\r\n				şifrelemeden farklı olarak, kısmi homomorfik şifreleme sadece belirli işlemler için \r\n				kullanılabilir.Kısmi-Homomorfik Şifreleme yönteminde ya çarpma işlemi ya da toplama\r\n				işlemi olmak üzere sadece bir tek işlem gerçekleştirebilir. RSA, ElGamal ve Paillier\r\n				Kısmi-Homomorfik Şifreleme özelliği göstermektedir.", true, "Kısmi-Homomorfik Şifreleme" },
                    { 153, 153, "Bu tür, şifreli veriler arasında çarpma işlemi yapılmasına \r\n						olanak tanır. Ancak, şifreli veriler üzerinde sadece çarpma\r\n						işlemi yapılabilir, toplama işlemi yapılamaz.", true, "Çarpma Kısmi Homomorfizması:" },
                    { 154, 154, "Bu tür, şifreli veriler arasında toplama işlemi yapılmasına olanak tanır.\r\n						Şifreli veriler üzerinde sadece toplama işlemi yapılabilir, çarpma işlemi yapılamaz.", true, "Toplama Kısmi Homomorfizması:" },
                    { 155, 155, "Kısmi homomorfik şifreleme, özellikle bulut bilişim ve veri güvenliği gibi alanlarda \r\n				kullanışlıdır. Örneğin, veri analizi veya hesaplama yaparken, hassas verilerin gizliliğini \r\n				koruyarak işlem yapılmasını sağlar. Ancak, tam homomorfik şifreleme kadar geniş bir \r\n				kullanım alanına sahip olmayabilir, çünkü yalnızca belirli işlemleri gerçekleştirmek için kullanılabilir.", true, "Lecture" },
                    { 156, 156, "RSA algoritması bilinen ilk Homomorfik Şifreleme yöntemlerinden biridir.\r\n				Çarpmaya göre Kısmi-Homomorfik Şifreleme özelliği gösterir. 𝑚1 1.\r\n				açık metin, 𝑚2 2. açık metin, 𝑛 mod değeri, 𝑦 açık anahtar olsun. RSA algoritmasının\r\n				çarpmaya göre Kısmi-Homomorfik Şifreleme özelliğini aşağıdaki gibi gösterilebilir;", true, "RSA Algoritması ve HE" },
                    { 157, 157, "Görüldüğü gibi iki açık metinin şifrelenmiş olarak çarpımı açık metin\r\n				olarak çarpımının şifrelenmiş haline eşittir.", true, "RSA Algoritması ve HE" },
                    { 158, 158, "ElGamal algoritması toplamaya göre Homomorfik Şifreleme özelliği\r\n				göstermektedir. 𝑚1 1. açık metin, 𝑚2 2. açık metin, 𝑦 mod değeri,\r\n				𝐾ortak anahtar olsun. ElGamal algoritmasının toplamaya göre Kısmi-Homomorfik\r\n				Şifreleme özelliğini aşağıdaki gibi gösterilebilir;", true, "ElGamal Algoritması ve HE" },
                    { 159, 159, "Görüldüğü gibi iki açık metinin şifrelenmiş olarak toplamı açık metin\r\n				olarak toplamının şifrelenmiş haline eşittir.", true, "ElGamal Algoritması ve HE" },
                    { 160, 160, "Paillier algoritması toplamaya göre Homomorfik Şifreleme özelliği\r\n				göstermektedir.Şifrelenmiş metinlerin toplamı, açık metinlerin\r\n				toplamına eşittir. 𝑚1 1. açık metin, 𝑚2 2. açık metin, 𝑛 mod değeri, 𝑔 açık anahtar, 𝑟\r\n				seçilen rastgele değer olsun. Paillier algoritmasının toplamaya göre Kısmi-Homomorfik\r\n				Şifreleme özelliğini aşağıdaki gibi gösterilebilir;", true, "Paillier Algoritması ve HE" },
                    { 161, 161, "Görüldüğü gibi iki açık metinin şifrelenmiş olarak toplamı açık metin\r\n				olarak  toplamının şifrelenmiş haline eşittir.", true, "Paillier Algoritması ve HE" },
                    { 162, 162, "Tam-Homomorfik Şifreleme, şifreli veriler üzerinde yapılan işlemler tek bir\r\n				işlem tipiyle sınırlı kalmadan, farklı işlem tiplerini sayısız sayıda yapmaya izin veren\r\n				yapılardır. Tam-Homomorfik Şifreleme yapısı temelde halka\r\n				homomorfizmi olarak düşünülebilir.", true, "Tam-Homomorfik Şifreleme" },
                    { 163, 163, "2009 yılında, Gentry ilk Tam-Homomorfik Şifreleme yapısını açıkladı. Bu yapı\r\n				Kısmi-Homomorfik ve Homomorfik Benzeri Şifrelemelerinin aksine hem toplama hem\r\n				çarpma işlemlerini bir arada ve sınırsız sayıda yapmayı destekliyordu. Gentry’nin\r\n				sunduğu yapı sadece bir Tam-Homomorfik Şifreleme yapısı olmasından bir yana, TamHomomorfik Şifreleme yapısı oluşturabilmek için nasıl bir yol izlenmesi gerektiğini\r\n				anlatıyordu. Gentry’nin sunduğu yapıdan sonra birçok kişi yeni bir Tam-Homomorfik\r\n				yapı tasarlamaya çalıştı.", true, "Tam-Homomorfik Şifreleme" },
                    { 164, 164, "Gentry’nin önerdiği yapı ideal kafes (ideal lattice) tabanlı bir yapıydı.\r\n				Gentry’nin sunduğu Tam-Homomorfik Şifreleme yapısından öncede kafes tabanlı\r\n				kriptoloji üzerinde çalışmalar devam etmekteydi. Bu yapı teorik olarak çok önemli bir\r\n				yeri olsa da, uygulanabilirliği konusunda hesaplama maliyeti gibi sebeplerden dolayı\r\n				çok verimli değildi. Bu yapının daha verimli bir hale getirilmesi için birçok çalışma\r\n				yapılmıştır.Yapılan yeni çalışmaların çoğu kafes problemlerindeki zorluğu güvenlik\r\n				olarak kullanmasına dayanmaktadır.", true, "Tam-Homomorfik Şifreleme" },
                    { 165, 165, "Gentry, ideal kafeslere dayanan SWHE bir yapı kurarak başlamıştır. Fakat belirli\r\n				bir işlem sayısından sonra elde edilen sonuçlar başarısız olmuştur. Bunun sebebi şifreli\r\n				metindeki gürültü miktarının fazla olmasından kaynaklıdır. Gentry,\r\n				blue print method denilen, Önyükleme (boostrapping) ve şifre çözme devresini\r\n				önyükleme yapılabilir hale getirmek için bir teknik (squashing) işlemlerini önerdi.\r\n				Boostrapping ve squashing işlemleri tekrar edebilir özelliktedir. Bundan dolayı\r\n				oluşturulan yapı bu işlemlere sokularak sınırsız sayıda toplama ve çarpma işlemi\r\n				gerçekleştirebilecektir.", true, "Tam-Homomorfik Şifreleme" },
                    { 166, 166, "Toplamı gizli anahtarın çarpımının tersine eşit olan bir vektör\r\n				kümesi seçilir. Eğer şifreli metin bu kümenin elemanları ile çarpılırsa devrenin polinom\r\n				derecesi şemanın kaldırabileceği seviyeye indirgenir. Şifreli metin artık boostrapping\r\n				yapılabilir bir durumdadır.", true, "Tam-Homomorfik Şifreleme Squashing:" },
                    { 167, 167, "Şifrelenmiş metin içerisindeki gürültüyü ortadan kaldırmak için\r\n				şifreli metini yeniden şifreleme işlemidir. Squashing işlemi gerçekleştirilerek\r\n				boostrapping yapılabilir bir duruma gelen şifreli metin boostrapping işlemi\r\n				gerçekleştirilerek yeni şifreli metin elde edilir.", true, "Tam-Homomorfik Şifreleme Boostrapping:" },
                    { 168, 168, "Yani, gürültü içeren şifreli metni şifre çözme işlemi uygulayarak gürültüyü\r\n				kaldırır ve sonradan tekrar şifreleme işlemi gerçekleştiğinde küçük gürültülü bir hale\r\n				getirir. Bu işlem gürültünün eşik noktasına ulaşana kadar tekrarlanabilir. Gentry’nin\r\n				sunduğu bu yapıda maliyetin çok fazla olduğu görülmektedir. Bu şekilde bir SWHE\r\n				yapısı oluşturup, squashing ve boostrapping işlemleri gerçekleştirerek bir FHE yapısı\r\n				oluşturulabilir.", true, "Tam-Homomorfik Şifreleme" },
                    { 169, 169, "Biraz homomorfik şifreleme (SHE), şifrelenmiş veriler üzerinde sınırlı bir şekilde matematiksel işlemler yapabilme yeteneğine sahip bir şifreleme türüdür. Bu tür şifreleme, verilerin gizliliğini korurken işlemler yapma ihtiyacı olan çeşitli uygulamalar için önemlidir.\r\n\r\n				Temel olarak, SHE şifreleme şeması, şifrelenmiş veriler üzerinde sınırlı bir homomorfik özelliğe sahiptir. Bu özellik, belirli matematiksel işlemleri gerçekleştirmenize olanak tanırken, şifrelenmiş verinin gizliliğini korur. SHE'nin en yaygın olarak kullanılan örneği, homomorfik olarak toplama işlemlerini gerçekleştirebilme yeteneğidir. Yani, iki şifreli sayıyı toplayabilir ve sonucu şifreli olarak elde edebilirsiniz.\r\n\r\n				Ancak, SHE'nin tam homomorfik şifreleme (FHE) kadar geniş bir işlem yelpazesine sahip olmadığını belirtmek önemlidir. SHE, çarpma gibi daha karmaşık işlemleri gerçekleştirmek için genellikle yetersizdir. Bu nedenle, SHE genellikle belirli uygulamalar için yeterli olan bir orta yol sağlar.\r\n\r\n				Özetle, SHE, verilerin gizliliğini korurken sınırlı matematiksel işlemler gerçekleştirmenizi sağlayan bir şifreleme türüdür. Bu özellikle bulut hesaplama, veri analizi gibi alanlarda gizliliğin korunması gereken durumlarda kullanılabilir.", true, "Biraz-Homomorfik Şifreleme (Somewhat-HE)" },
                    { 170, 170, "Günümüzde insanların genom haritaları çıkarılma çalışmaları hızlı bir şekilde\r\n				sürmektedir. Yakın bir gelecekte dünya üzerindeki insanların birçoğunun genom\r\n				haritalarına sahip olacağız. Biyoloji, tıp ve insanlığın varoluşu konuları hakkında bu\r\n				bilgilerin bize yardımcı olmaları beklenmektedir. Genom haritaları bilgisi\r\n				laboratuarlarda ve tıp merkezlerinde tutulmaktadır. Fakat bu verilerin saklanmasında ve\r\n				paylaşılmasında insanların güvenliği ve gizliliği açısından sıkıntılar doğmaktadır. DNA\r\n				ve RNA bir insanın parmak izi gibi özel bir tanımıdır. Bu bilgilerin güvenliğinin\r\n				sağlanmadan paylaşılması büyük bir sorun teşkil etmektedir.\r\n				Genom verilerin korunması National Institutes of Health tarafından\r\n				sağlanmaktadır. Bu verilere güvenli erişim için devlet kontrolü altında veya güvenilir\r\n				ortaklar tarafından erişim sağlanmaktadır. Bu verilerin hızlı bir şekilde artmasından\r\n				dolayı bulut tabanlı yeni çalışmalar önerildi. Fakat şuan için bu verilerin bulut ortamına\r\n				aktarılması güvenli değildir.\r\n				Genom verilerinin bazıları veriler üzerinde işlemlerin yapılarak belirli bir sonuç\r\n				elde etmeye dayanmaktadır. HE yöntemi ile buluta yüklenecek genom verilerinin\r\n				bazıları üzerinde güvenli bir şekilde işlem yapılabilirliği sağlanabilir.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Genom ve HE" },
                    { 171, 171, "Hükümete bağlı bulunan bina, şebeke, jeneratör vb. gibi yapıların birbiri ile\r\n				bağlantılığı olduğu akıllı bir şebeke ağı oluştuğunda, bu yapılar belirli bir veri\r\n				üretecektir. Bu verilerin çeşitli hükümet organları ile paylaşılarak gerekli analizlerin ve\r\n				incelemelerin yapılması gerekmektedir. Bu işlemlerin güvenli bir şekilde yapılabilmesi\r\n				için HE yapısından faydalanarak gerekli hesaplamalar ve incelemeler yapılabilir. Bu tür\r\n				bilgiler ile kötü amaçlı yazılımlar, anormallikler ve izinsiz girişlerin tespiti yapılarak\r\n				güvenlik sağlanabilir.\r\n				Böyle bir yapı çok fazla alandan çok fazla bilgi içerdiği için bu bilgileri korumak\r\n				ve kötü kişiler tarafından ele geçirilmediğini sağmak çok önemlidir. Örnek olarak,\r\n				şebeke ve güç dağılımı bilgilerinin kötü kişiler tarafından ele geçirildiğinde, bu alanlara\r\n				saldırılar olabilir.\r\n				Herhangi başka bir uygulama ile bu güvenliği sağlamak, uygulamada kullanılan\r\n				yöntemlerin belirgin olamaması, algoritmaların bilinmemesi ve protokollerin\r\n				güvenilirliğinin test edilememesi durumlarından dolayı kesin değildir. Bu nedenle kritik\r\n				alanlarda HE yöntemi kullanmak çok daha iyi olabilmektedir.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Ulusal Güvenlik ve HE " },
                    { 172, 172, "ABD’de her geçen yıl 1 milyondan fazla öğrenci lise zamanı okulu\r\n				bırakmaktadır (2017 verilerine göre). Liseye başlayan öğrencilerin çeyreği okulunu\r\n				zamanında bitirememektedir. Bu problemi en aza indirgemek için; liseyi bitirememe ve\r\n				liseyi zamanında tamamlayamama grubunda olabilecek öğrencileri liseye başlamadan\r\n				önce tespit edip gerekli önlemler alınabilir. Böyle bir tespitin yapılabilmesi için\r\n				hükümete bağlı okul, hastane, polise vb. kurumlardaki bilgilerin birleştirerek analiz\r\n				edilmesi gerekmektedir.Fakat bu kurumların hepsinin kendi bilgilerini koruma ve\r\n				güvenliğin sağlamakla yükümlüdür.\r\n				Bütün bu bilgilerin tek yerde tutulması büyük bir risk oluşturmaktadır. Bu denli\r\n				büyük bir bilgi kötü kişiler tarafından ele geçirmeye çalışılabilir ve sürekli saldırı\r\n				altında olabilir.\r\n				HE yapısından faydalanarak bu bilgilerin herhangi bir yere taşınmasına gerek\r\n				kalmadan hesaplanabilir hale getirilebilir. Bu şekilde güvenlik en üst düzeyde tutulmuş\r\n				olacaktır.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Eğitim ve HE" },
                    { 173, 173, "Sağlık hizmetlerinde kişilerin hassas bilgileri bulunmaktadır. Bu bilgilerin\r\n				güvenliğinin iyi sağlanması kötü kişiler tarafından ele geçirilmemesi çok önemlidir.\r\n				Fakat bir yandan bu bilgilerin sürekli olarak işlenmesi gerekmektedir. Risk ve fayda\r\n				arasındaki bu bilgilerin doğru bir şekilde korunmadığında bilgi kaybının yanında büyük\r\n				maliyetlere sebep olduğu görülmektedir.\r\n				HE yapısı sağlık hizmetlerindeki bilgilerin risk ve fayda dengesini sağlamada rol\r\n				oynayabilir. Fatura, rapor oluşturma gibi yapılacak işlemlerin yapılması sırasında\r\n				bilgilerin gizli kalmasını sağlayıp sadece sonucun elde edilmesini sağlayabilir. Bu\r\n				şekilde verilerin güvenliği sağlanarak, büyük maliyetlere sebebiyet verecek olaylardan\r\n				korunmasını sağlar.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Sağlık ve HE" },
                    { 174, 174, "Bulut Bilişim, günümüzde popüler bir şekilde kullanılan internet üzerinde\r\n				verilerin depolanabileceği bir teknolojidir. Bulut bilişim, ulaşılabilirliğin kolay olması\r\n				ve maliyetinin düşük olmasından dolayı çok tercih edilmektedir. Aynı zamanda kişisel\r\n				verilerin bu teknoloji üzerinde tutulmasından dolayı, saldırganlar için potansiyel bir\r\n				saldırma yeridir. Saldırıya uğrayan bir bulutun, kişisel verileri nasıl koruyacağına dair\r\n				sorunlar gündeme gelmektedir. Bu sorunu çözebilmek için bulut üzerinde tutulan\r\n				verilerin şifreli bir şekilde saklanması gerekmektedir. Saldırgana kullanıcı verilerine\r\n				ulaşabile şifreli oldukları için herhangi bir şey elde edemez. Fakat verilerin şifreli bir\r\n				şekilde tutulması kullanıcıların verilerine ulaşmak istemesi veya üzerinde değişiklikler\r\n				yapmak istemesi halinde şifreleme ve şifre çözme işlemleri gerçekleştirmek\r\n				gerekmektedir. Bu işlemler ek maliyetler getirecektir.\r\n				HE yapısı bulut bilişiminde kullanılabilir. HE yapısı sayesinde şifrelenmiş\r\n				olarak saklanan veriler üzerinde kullanıcılar gerekli işlemleri gerçekleştirerek maliyet\r\n				düşürülebilir. Veriler şifreli olacağı için saldırganlar tarafından da korunaklı bir yapı\r\n				haline gelecektir.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Bulut Bilişim ve HE " },
                    { 175, 175, "Mobil ajanlar, kullanıcıların önceden belirlenmiş olan görevleri kullanıcıların\r\n				müdahalesi gerekmeden başka bilgisayarlar üzerinde gerçekleştiren programlardır.\r\n				Mobil ajanların çalıştığı diğer bilgisayarların kötü niyetli\r\n				kişiler tarafınca kontrol edilebilmesinden dolayı güvenlik açığı ortaya çıkmaktadır.\r\n				Bundan dolayı mobil ajanları kötü niyetli kişiler tarafından korumak ve işlemlerini\r\n				gerçekleştirmek için HE yapısı kullanılabilir. Verileri, mobil ajanlar tarafından başka\r\n				bilgisayarlarda kullanılmadan önce şifrelemek ve sonrasında şifreli veriler üzerinde\r\n				hesaplama yapmak için HE yapısından faydalanılabilir.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Mobil Ajan ve HE" },
                    { 176, 176, "Elektronik ortamda gizli oylama sistemlerinde, oylar üzerinde işlemlerin\r\n				yapılması gerekmektedir. Yapılacak olan bu işlemler sırasında, oy veren bireylerin\r\n				kullandıkları oy hakkındaki bilgilerin gizlilik nedeni ile ortaya çıkarılmaması\r\n				gerekmektedir. Şifreli olarak saklanan oylar üzerinde işlem yapabilmek için HE yapısı\r\n				kullanılabilir. Bu sayede oylar üzerinde analizler yapılırken, oyların gizliliği\r\n				sürdürülebilir.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Oylama ve HE " },
                    { 177, 177, "Finansal sektörde müşteriler tarafından şirketlere yapılacak yatırımlar, şirket\r\n				hakkındaki bilgiler doğrultusunda yapılmaktadır. Bu bilgiler, şirketin performansı,\r\n				envanter durumu gibi bilgilerden oluşmaktadır. Bu bilgiler üzerinde hesaplamalar\r\n				yapılarak şirket hakkında gerekli bilgiye sahip olan müşteri yatırım yapıp\r\n				yapmayacağına karar verir. Şirketler bu bilgileri avantajlarını koruyabilmek için gizli\r\n				tutmak isteyebilirler.\r\n				Şirketler HE yapısı kullanılarak bu bilgileri açık bir şekilde yayınlamadan\r\n				müşteriler tarafından kullanılabilir bir yapı oluşturabilir. Bu sayede şirketler bilgilerini\r\n				açık bir şekilde paylaşmamış ve müşteriler şirket bilgileri hakkında yapmak istedikleri\r\n				hesaplamaları yapabilirler.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Finans ve HE" },
                    { 178, 178, "Reklam, satıcının sattığı ürün veya hizmetin müşteriler tarafından bilinmesini\r\n				sağlayan bir araçtır. Reklam veren satıcıların asıl ulaşmak istedikleri kişiler potansiyel\r\n				alıcılardır. Potansiyel alıcıların kimler olduğunu belirlemek için, insanların kullandıkları\r\n				bilgisayar, telefon gibi iletişim içerisinde olan elektronik eşyalar kullanılır. Bu eşyaları\r\n				kullanan insanların; aradıkları kelimeler, ilgi alanları, e-postalar, konum bilgileri gibi\r\n				bilgilerini toplayarak, o kişi hakkında bilgi sahibi olunabilir. Toplanan bu bilgiler\r\n				sayesinde reklam yapan satıcıların sattığı ürünün veya hizmetin potansiyel alıcısı olduğu\r\n				tahmin edilen kişilere sunulması. Bu sayede satıcıların müşterileri ile kolay bir şekilde\r\n				buluşması sağlanabilir.\r\n				HE yapısı sayesinde kişilerden toplanan kişisel bilgilerin açık olarak saklanması\r\n				gerekmemektedir. Şifreli olarak saklanan bilgilerin, gerektiğinde şifreli olarak işlem\r\n				yapılarak sonuçları üzerinden potansiyel alıcılar belirlenebilir.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Reklam ve HE " },
                    { 179, 179, "Veri kümeleme, ağ içerisinde bulunan algılayıcıların veri miktarlarını düşürerek\r\n				enerji tasarrufu yapmasını sağlayan bir yapıdır. Güvenlik sorunları ile karşılaşılmaması\r\n				için veri gönderecek tarafın veriyi şifreleyerek baz istasyonuna göndermesi\r\n				gerekmektedir. Fakat verinin gideceği yol üzerindeki algılayıcılar veriyi açık metin\r\n				haline getirerek veri kümele işlemi yapması gerekmektedir. Güvenlik ve veri kümeleme\r\n				birbirlerine zıt bir şekilde çalışmaktadır.\r\n				Veriyi baz istasyonuna gönderen taraf veriyi simetrik anahtar şifreleme ile\r\n				göndermektedir. Ağ üzerindeki algılayıcılar şifre çözme işlemi ile veriyi çözer, veri\r\n				kümeleme yapar ve sonrasında tekrar şifreleme işlemini gerçekleştirerek veriyi\r\n				gönderir. Veri bu işlemler sırasında gizliliğini yitirmektedir.\r\n				Hem veri gizliliğini sağlamak hem de veri kümele işlemini gerçekleştirmek için\r\n				HE yapısından faydalanılabilir. HE yapısı sayesinde veriyi baz istasyonuna gönderen\r\n				taraf veriyi şifreleyerek gönderir. Ağ üzerindeki algılayıcılar şifre çözme işlemini\r\n				gerçekleştirmeden veri kümele işlemini yapar ve veriyi gönderir. Bu sayede şifreli veri\r\n				yol boyunca açılmadı için veri gizliliği sağlanmış ve veri kümele işlemi\r\n				gerçekleştirilmiş olur.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Kablosuz Algılayıcı Ağlarda Güvenli Veri Kümeleme ve HE " },
                    { 180, 180, "IoT, etrafımıza etkide bulunan veya analiz etmemizi sağlayan cihazları etkileşim\r\n				içinde olmalarını sağlayan bir iletişim ağıdır. Bu iletişim ağı sayesinde üretim\r\n				süreçlerini, hasta takipleri, geri dönüşüm süreçleri, akıllı binalar gibi alanlarda kontrol\r\n				sağlanabilir ve analiz yapılabilir.\r\n				Standart şifreleme yöntemlerinden faydalanarak IoT oluşturulduğunda iki tane\r\n				problem ortaya çıkmaktadır. Eğer veriler şifrelenmemiş olarak depolanırsa, kötü niyetli\r\n				kişiler tarafından ele geçirilebilir. Eğer veriler şifrelenmiş olarak depolanırsa,\r\n				sağlayıcılar üzerinde çalışması için şifrenin çözülmesi gerekir.\r\n				HE sayesinde veriler şifrelenmiş şekilde depolanarak, şifre çözme işlemine gerek\r\n				kalmadan sağlayıcılar üzerinde işlem yapılabilir. RSA algoritması, ElGamal\r\n				algoritması, Paillier algoritması bu amaç ile kullanılabilir. IoT için Homomorfik\r\n				Şifreleme çok önemlidir. Çünkü bir yandan veri gizliliğini koruyarak, bir yandan da\r\n				sağlayıcılar ve düğüm noktalarında hızlı bir şekilde şifre çözme ve şifreleme işlemlerine\r\n				gerek duymadan gerçekleştirilebilir. Düğümlerde toplama ve çarpma işlemleri\r\n				gerçekleştirilerek işlem ve depolama maliyeti azaltılabilir. Bu sayede düşük güç\r\n				tüketimi gerçekleşmiş olur.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Internet of Things (IoT) ve HE" },
                    { 181, 181, "Veri tabanı düzenli şekilde verilerin saklandığı bilgi topluluğudur. Veri\r\n				tabanındaki verilere istenildiği zaman ulaşılabilir ve kullanılabilir.\r\n				Bu veriler veri tabanında güvenlik için şifreli bir şekilde bulunmaktadır. Fakat veriler\r\n				üzerinde gerçekleştirilecek işlemlerin yapılması sırasında bu verilerin şifrelerinin\r\n				çözülmesi ve açık metin üzerinde işlemlerin gerçekleşmesi gerekmektedir. Bu nedenle,\r\n				veri tabanındaki veriler güvenlik riskleri ile karşı karşıyadır.\r\n				HE yapısı veriler üzerinde şifre çözme işlemini gerçekleştirmeden işlemler\r\n				yapılabilmesine olanak sağlamaktadır. Bu sayede veri tabanında saklanan veriler\r\n				üzerinde işlemler güvenli bir şekilde gerçekleşebilir.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Veri Tabanı Güvenliği ve HE " },
                    { 182, 182, "Ağ kontrol sistemleri siber güvenliğin en önemli konularından biridir. Su, ulaşım\r\n				ve elektrik ağları gibi endüstriyel ve kritik altyapılara uygulanır. Kötü niyetli kişiler bu\r\n				ağlara karşı saldırılarda bulunmaktadır. İletişim kanalları üzerinden gönderilen\r\n				sinyallerin güvenliği sağlanmalıdır (Kogiso & Fujita, 2015).\r\n				Kontrol cihazının parametrelerini ve kontrol cihazı içerisindeki sinyalleri\r\n				şifrelemek güvenlik açısından önemlidir. Kontrol cihazına gelene sinyal şifreli bir\r\n				şekilde gelerek şifre çözme işlemi gerçekleştirilir ve gerekli işlemlerin yapılması\r\n				sonucunda tekrar şifrelenerek şifreli olarak kontrol cihazından çıkış gerçekleştirir. HE\r\n				yapısı kontrol cihazlarında uygulandığında şifreli olarak gelen sinyal şifre çözme işlemi\r\n				gerçekleşmeden gerekli işlemler üzerinde gerçekleştirilerek şifreli olarak çıkış\r\n				gerçekleştirir. Bu sayede ağ kontrol cihazları üzerinde güvenlik arttırılmış olacaktır.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Ağ Kontrol Sistemleri ve HE  " },
                    { 183, 183, "Açık arttırma bir malın, menkulün, eşyanın vb. ürünlerin alıcı ve satıcıların bir\r\n				arada bulunarak fiyat tekliflerinin bildirilmesi ile en yüksek fiyata sahip alıcının ürünü\r\n				almasıdır. Açık arttırmalar açık teklif veya kapalı teklif şeklinde ikiye ayrılmaktadır.\r\n				Açık teklif şeklinde gerçekleşen açık arttırmalarda, alıcılar fiyat tekliflerini açık bir\r\n				şekilde gerçekleştirirler. Kapalı teklif şeklinde gerçekleşen açık arttırmalarda, alıcılar\r\n				fiyat tekliflerini kapalı bir şekilde gerçekleştirirler.\r\n				Kapalı teklif açık arttırmalarda, alıcıların verdikleri teklifler gizli olmalıdır. Bu\r\n				tekliflerin açığa çıkması açık arttırmayı olumsuz yönde etkilemektedir. Bir yandan bu\r\n				tekliflerin karşılaştırma işlemleri gerçekleştirilmesi gerekmektedir. Burada üçüncü\r\n				şahıslara olan güven esas alınmaktadır.\r\n				HE yapısı kapalı teklif açık arttırmalarda uygulanabilir. Bu sayede alıcılar\r\n				tarafından verilen teklifler şifreli bir şekilde saklanır. Karşılaştırmaların yapılması için\r\n				şifreli olarak saklanan veriler şifre çözme işlemine gerek olmadan gerekli işlemler\r\n				üzerinde gerçekleştirilebilir. Bunun sonucunda, teklifler üçüncü bir şahıssa güven\r\n				olmayı gerektirmeden açık arttırma gerçekleşebilir.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Kapalı Teklif Açık Arttırma ve HE" },
                    { 184, 184, "Homomorfik şifreleme, verileri şifrelerken, şifrelenmiş veri üzerinde işlemler yapılabilir \r\n					hale getirir. Ancak bu işlemler sonucunda elde edilen çıktılar, şifrelenmiş veriden doğrudan anlamlı \r\n					bir şekilde yararlanılmasını önlemek için tekrar şifrelenmiş olmalıdır. Bu sayede, veri sahiplerinin \r\n					gizli verilerinin ifşa edilmesi önlenir.", true, "Homomorfik Şifreleme Teknolojisinin Güvenlik ve Gizlilik İlkeleri Veri Gizliliği:" },
                    { 185, 185, "Homomorfik şifreleme, şifreli veri üzerinde işlemler yapılabilmesini sağlar, ancak \r\n					bu işlemler sonucunda verinin bütünlüğünün korunması kritiktir. Yani, işlenmiş verinin, orijinal \r\n					veriden doğru bir şekilde türetildiğinden emin olunmalıdır.", true, "Homomorfik Şifreleme Teknolojisinin Güvenlik ve Gizlilik İlkeleri Veri Bütünlüğü:" },
                    { 186, 186, "Homomorfik şifreleme sistemlerinde kullanılan şifreleme \r\n					anahtarlarının güvenliği büyük önem taşır. Eğer bir saldırgan anahtarları ele geçirirse, bu \r\n					saldırganın şifrelenmiş veri üzerinde istediği işlemleri yapması mümkün olabilir.", true, "Homomorfik Şifreleme Teknolojisinin Güvenlik ve Gizlilik İlkeleri Şifreleme Anahtarının Güvenliği:" },
                    { 187, 187, "Veri işleme sürecinde, verinin kim tarafından işlendiğinin \r\n					doğrulanması önemlidir. Bu nedenle, hem veri işleme sürecinin hem de işlem sonuçlarının \r\n					doğrulanması için güvenilir doğrulama mekanizmaları gereklidir.", true, "Homomorfik Şifreleme Teknolojisinin Güvenlik ve Gizlilik İlkeleri Doğrulama ve Kimlik Doğrulama:" },
                    { 188, 188, "Homomorfik şifreleme sistemleri, çeşitli saldırılara karşı dirençli olmalıdır. Özellikle\r\n					kriptografik saldırılara karşı dayanıklı olmalı ve saldırganların şifreli veriyi kırmak için \r\n					kullanabilecekleri yöntemlere karşı korunaklı olmalıdır.", true, "Homomorfik Şifreleme Teknolojisinin Güvenlik ve Gizlilik İlkeleri Saldırı Direnci:" },
                    { 189, 189, "Bu ilkeler, homomorfik şifreleme teknolojisinin güvenliği ve gizliliği sağlamak için temel alınan \r\n				prensiplerdir. Bu ilkeler, bu teknolojinin güvenilir ve etkili bir şekilde uygulanmasını sağlamak için\r\n				dikkate alınmalıdır.", true, "Homomorfik Şifreleme Teknolojisinin Güvenlik ve Gizlilik İlkeleri" },
                    { 190, 190, "Homomorfik şifreleme ve veri analitiği arasındaki ilişki, veri gizliliği ve güvenliği ile veri \r\n				analitiği arasında bir denge kurma ihtiyacından doğar. İşte bu konudaki potansiyeller ve zorluklar:", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar" },
                    { 191, 191, "Potansiyeller:", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar Potansiyeller:" },
                    { 192, 192, "Homomorfik şifreleme, verilerin analiz edilmesine olanak tanırken, aynı zamanda \r\n				verilerin gizliliğini korur. Bu, hassas verilerin analiz edilmesi için güvenli bir \r\n				ortam sağlar, çünkü veriler şifreli olarak kalır ve analiz sırasında açık metin haline gelmez.", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar Veri Gizliliği Koruması:" },
                    { 193, 193, "Homomorfik şifreleme, farklı kurumlar arasında hassas verilerin güvenli bir şekilde\r\n				paylaşılmasını sağlar. Veriler şifreli olduğu için, paylaşım sırasında gizliliği \r\n				korunurken, analiz yapmak isteyen kurumlar bu verilere erişebilir.", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar Veri Paylaşımında Esneklik:" },
                    { 194, 194, "Homomorfik şifreleme sayesinde, özellikle sağlık, finans ve diğer hassas alanlardaki\r\n				verilerin analizi mümkün hale gelir. Örneğin, sağlık verileri gibi özel\r\n				veriler, analiz edilirken bile gizliliği korunarak değerlendirilebilir.", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar Hassas Veri Analizi İmkanı: " },
                    { 195, 195, "Zorluklar:", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar Zorluklar:" },
                    { 196, 196, "Homomorfik şifreleme, hesaplama yoğun işlemler gerektirir. Özellikle \r\n				büyük veri kümeleriyle çalışırken, homomorfik işlemlerin yapılması \r\n				zaman alabilir ve yüksek hesaplama gücüne ihtiyaç duyabilir.\r\n", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar Hesaplama Gücü İhtiyacı:" },
                    { 197, 197, "Homomorfik şifreleme, geleneksel veri analitiği yöntemlerine göre \r\n				daha yavaş olabilir. Bu nedenle, gerçek zamanlı analizler veya \r\n				hızlı yanıtlar gerektiren uygulamalarda kullanılması zor olabilir.", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar Performans:" },
                    { 198, 198, "Homomorfik şifreleme, karmaşık kriptografik algoritmaları\r\n				gerektirir. Bu algoritmaların tasarımı ve uygulanması zor \r\n				olabilir ve hatalı bir şekilde uygulandığında güvenlik riski oluşturabilir.", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar - Kriptografik Zorluklar:" },
                    { 199, 199, "Homomorfik şifreleme, verilerin boyutunu artırabilir. Özellikle şifreleme sırasında \r\n				veri genişleyebilir ve bu da depolama ve iletim maliyetlerini artırabilir.", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar - Veri Boyutu ve Boyut Artışı: " },
                    { 200, 200, "Homomorfik şifreleme ve veri analitiği arasındaki ilişki, veri gizliliği ve analitik esneklik \r\n			arasında bir denge kurmayı gerektirir. Potansiyelleri, veri gizliliğini korurken veri analitiğini \r\n			mümkün kılar. Ancak zorluklar, performans, hesaplama gücü ve kriptografik zorluklar gibi teknik engellerle karşılaşabilir.", true, "Homomorfik Şifreleme ve Veri Analitiği: Potansiyeller ve Zorluklar Performans:" },
                    { 201, 201, "Avuç ve parmak izi tanıma teknolojileri özellikle son yıllarda daha fazla\r\n				kullanılmaya başlamıştır. Avuç ve parmak uçlarındaki deri üzerindeki dalgalanmaların\r\n				karakteristik bir yapıya sahip olmasında dolayı, bu veriler ile tanımlama işlemleri\r\n				gerçekleştirilmektedir. Bu uygulamaların sahip\r\n				olduğu kişisel avuç ve parmak izi verilerinin şifreli bir şekilde tutularak ve gerektiğinde\r\n				bu işlemlerin şifreli bir şekilde yapılması güvenlik için önemlidir. HE yapısı ile bu\r\n				uygulamalardaki güvenlik arttırılabilir.", true, "HOMOMORFİK ŞİFRELEME UYGULAMALARI Avuç ve Parmak İzi ve HE" }
                });
        }
    }
}
